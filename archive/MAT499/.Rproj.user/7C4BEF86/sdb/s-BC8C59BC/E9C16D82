{
    "contents" : "### Learning how to use ROCR\n### Comparing ROCR of logit, ridge and LASSO\nrequire(ROCR); require(knitr)\ndata39lagraw <- read.csv(file='/Users/cuongnguyen/Program/Git/mat499/fullData39Lag.csv',header=TRUE)\ndata39lagraw <- data39lagraw[c(-1)]\n\nhead(data39lagraw)\n\n##### NOTE: data need to be standardized! or lasso will perform the worst\n#####\n\n# Standadize the data \ndata39lag <- data.frame(scale(data39lagraw[-61]))\nis.matrix(data39lag)\ndata39lag$Y <- data39lagraw$X.1\nhead(data39lag)\n#logit1 <- glm(Y ~ ., data=data39lag, family=binomial)\nlogit2 <- glm(Y ~ . + fromInDegree*fromSecondLevelInNodeInDeg + toInDegree*toSecondLevelOutNodeOutDeg   \n              -X1 - X2 - X3 -X4 - fromCloseness - toCloseness, data=data39lag, family=binomial)\nattach(data39lag)\npredict.plot(Y ~ fromInDegree | fromOutDegree, data=data39lag )\n\n\nsummary(logit2)\n\n# Step 0: vectors of output and labels\n# Vector of prediction \nglm.prob <- predict(logit2, type = \"response\")\n\n# Vector of lable is just Y\n\n\n# Step 1: Create an object of type prediction using ROCR\npred1 <- prediction(predictions=glm.prob, labels=data39lag$Y)\n\n# Step 2: Create an object of type performance using ROCR\nperf1 <- performance(pred1, \"tpr\", \"fpr\")\n\nplot(perf1, avg= \"threshold\", colorize=T, lwd= 3,main= \"Logit model, AUC=0.756\")\n\n# Step 3: Get the AUC\nauc1 <- performance(pred1,\"auc\")\n# now converting S4 class to vector\nauc1 <- unlist(slot(auc1, \"y.values\"))\n\ndata39lag$weight\n\nqplot(fromInDegree, toInDegree, col = Y, data=data39lag, xlim= c(-1,4), ylim = c(-1,0.5))\n\nqplot(fromInDegree, fromOutDegree, col = Y, data=data39lag, xlim= c(-0.5,1), ylim = c(-0.5,0.5))\nqplot(fromInDegree*weight, fromOutDegree*weight, col = Y, data=data39lag, xlim= c(-1,3), ylim = c(-1,3))\n\n\nqplot(toInDegree, fromInDegree, col = Y, data=data39lag, xlim= c(-1,5), ylim = c(-1,5))\n\nqplot(percentOf.1., weight, col = Y, data=data39lag)\nqplot(countOfSwitch, weight, col = Y, data=data39lag)\nqplot(countOfSwitch*weight, fromInDegree, col = Y, data=data39lag)\nqplot(countOfSwitch, fromInDegree, col = Y, data=data39lag)\nqplot(countOfSwitch, fromInDegree, col = Y, data=data39lag)\nqplot(fromInDegree*fromSecondLevelInNodeInDeg, fromInDegree, col = Y, data=data39lag)\nqplot(fromInDegree, fromSecondLevelInNodeInDeg, col = Y, data=data39lag,xlim= c(-1,5), ylim = c(-1,5))\n\npairs(~ Y +percentOf.1.+ countOfSwitch + fromSecondLevelInNodeInDeg + fromSecondLevelOutNodeOutDeg\n      ,data=data39lag)\n\n\npairs(data39lag[50:61])\n\nqplot(fromInDegree, toInDegree, col = Y, data=data39lag)\nqplot(fromInDegree, toInDegree, col = Y, data=data39lag)\n\n\n?pairs\n\n\n\n\n# Ridge regression --------------------------------------------------------\ninstall.packages(\"glmnet\"); require(glmnet)\n\n# glmnet() take a different input so we need different syntax here\n# create the matrix x and then y\nx <- model.matrix(Y~., data39lag)\ny <- data39lag$Y\n\n# create a grid to try different lambda\ngrid <- 10^seq(10, -2, length=100)\n# Fit ridge:alpha=0 is ridge, =1 is lasso\nridge.mod <- glmnet(x,y,alpha=0, lambda=grid, thresh=1e-12)\n\ndim(coef(ridge.mod))\nridge.mod$lambda[50]\n\n# create vector of prediction:\nridge.pred = predict(ridge.mod, s=212, newx=x)\npar(mfrow=c(2,3))\n\ndim(ridge.pred)\nlength(glm.prob)\n\n# now to the fun part of AUC! \n\npred2 <- prediction(predictions=ridge.pred, labels=y)\nperf2 <- performance(pred2, \"tpr\", \"fpr\")\nplot(perf2, avg= \"threshold\", colorize=T, lwd= 3,main= \"Ridge, Lambda=4, AUC=0.731\")\n\n# Get the AUC\nauc2 <- performance(pred2,\"auc\")\n# now converting S4 class to vector\nauc2 <- unlist(slot(auc2, \"y.values\"))\n\n\n# Now try LASSO\nlasso.mod <- glmnet(x,y,alpha=1, lambda=grid)\nplot(lasso.mod)\nlasso.pred = predict(lasso.mod, s=0.005, newx=x)\nlasso.pred\n\npred3 <- prediction(predictions=lasso.pred, labels=y)\nperf3 <- performance(pred3, \"tpr\", \"fpr\")\nplot(perf3, avg= \"threshold\", colorize=T, lwd= 3,main= \"LASSO, AUC = 0.745\")\n\n# Get the AUC\nauc3 <- performance(pred3,\"auc\")\n# now converting S4 class to vector\nauc3 <- unlist(slot(auc3, \"y.values\"))\n\n###### Now randomly create data:\nnorm.pred = rnorm(n=length(y))\nbinom.pred = rbinom(size=1,n=length(y),prob=0.99)\n\npred4 <- prediction(predictions=binom.pred, labels=y)\nperf4 <- performance(pred4, \"tpr\", \"fpr\")\nauc4 <- performance(pred4,\"auc\")\nauc4 <- unlist(slot(auc4, \"y.values\"))\n\nplot(perf4, avg= \"threshold\", colorize=T, lwd= 3,main= \"Random guess alltrue\\n AUC=0.501\")\n",
    "created" : 1392961514385.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2610234591",
    "id" : "E9C16D82",
    "lastKnownWriteTime" : 1393013482,
    "path" : "~/Program/Git/mat499/AUClogit-ridge-lasso.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}