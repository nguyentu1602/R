{
    "contents" : "# Chapter 1: Data, Modes & classes ----------------------------------------\nmode()\nclass()\ntypeof()\n# Matrices or other arrays require all the data contained to be in the same mode\n# Lists and dataframes allow for multiple modes within an object\n# The most primitive mode of data is char\nx = c(1,2,5,10, TRUE)\nmode(x)\ny = c(1,2,\"cat\", 5)\nmode(y)\nz = c(x, y) #You can combine vectors to make a new vactor\n# To name the elements of vectors, there are 2 ways:\nx = c(one=1, two=2, three=3)\ny = c(1,2,3)\nnames(y) = c('one','two', 'three')\n# To make a matrix:\nrmat = matrix(rnorm(15), 5, 3, dimnames= list(NULL, c('A', 'B', 'C')))\n# To change the names of columns in matrix\ndimnames(rmat) = list(NULL,c('A','B','C'))    \n# To call a column in a matrix\nrmat[,'A'] \n# To make a list\nmylist = list(c(1,4,6),\"dog\",3,\"cat\",TRUE,c(9,10,11))\n# To call/change a element in a list\nmylist[1]\nmylist[4] = 'catttt'\n# To name list's elements: 2 ways\nmylist = list(first=c(1,3,5), second=c('one','three','five'),third='end')\n  # or\nmylist = list(c(1,3,5),c(’one’,’three’,’five’),’end’)\nnames(mylist) = c(’first’,’second’,’third’)\n\n# A data frame is a list that each element (the variables) must be of the same length as every other element\n# Some function to test mode:   is.list, is.factor, is.numeric, is.data.frame, and is.character\n\n# To view structure of a nested list, use str()\nnestlist = list(a=list(matrix(rnorm(10),5,2),val=3),\n                b=list(sample(letters,10),values=runif(5)),\n                c=list(list(1:10,1:20),list(1:5,1:10)))\nstr(nestlist)\n\n# To convert types of objects, use as.\nnums = c(12,10,8,12,10,12,8,10,12,8)\ntt = table(nums)\nnames(tt)\nsum(as.numeric(names(tt)) * tt)\n\n# To test missing values, use is.na\n\n\n# Chapter 2: Reading and Writing Data -------------------------------------\n# 2.1 Reading Vectors and Matrices\n\n# To use standard input:\nnames = scan(what=\"\") # A prompt will show up\n# To entry a record:\nnames = scan(what=list(a=0,b=\"\",c=0))\n1 dog 3\n\n# To read into a matrix through a prompt, use a nested scan()\nmymat = matrix(scan(),ncol=3,byrow=TRUE) # Notice the byrow = TRUE\n\n# To skip fields while reading in data with scan(), use NULL to pass on 'what'\n# Suppose we only need to read the contents of the first, third, and tenth fields:\ntoskip = c(f1=0,NULL,f3=0,rep(list(NULL),6),f10=0)\nvalues = scan(filename, what=toskip) # Code will not run btw\nresult = cbind(values$f1,values$f3,values$f10)\n\n# 2.2 Data frame: read.table(), which always returns a data frame and automatically convert data\n  # To avoid conversion, use as.is = TRUE\n\n# 2.3 Comma and tab-delimited input files: use read.csv(), read.csv2(), read.delim()\n# 2.4 Fixed-width input files: use read.fwf()\n# 2.5 Extracting from R objects: use a set of appropriate functions with each class\n  # use apropos() to find all such function, for example:\napropos('.*\\\\.lm$')\napropos('.*\\\\.anova$')\n  # use names() to get all elements in each objects, then extract using & or []:\n  #   slm$df.residual is equivalent to slm['df.residual']\n# 2.6 & 2.7 Connections: read from files or server - page 23. Will come back\n# 2.8 Generating data\n  # Sequences\n1:10\nseq(1,10)\n1:10 - seq(1,10)\nseq(10,100,5)\nseq(10, by=5, length=10)\n  # Generating levels: use gl():\nthelevels = data.frame(group=gl(3,10,length=30),\n                       subgroup=gl(5,2,length=30),\n                       obs=gl(2,1,length=30))\n  # expand.grid() - very cool!\noe = expand.grid(odd=seq(1,5,by=2), even=seq(2,5,by=2))\n\n  # Random numbers: eg: rbinom() or rlogis() etc... Full table page 29\n# 2.9 Permutations: use sample() and factorial(n)\n# 2.10 Working with sequences: \n# 2.11 Spreadsheets: RODBC (win only) and gdata packages\n# 2.12 Saving into .RData or .rda files: use save() and load()\nsave(list=c('x','y','z'),file='mydata.rda')\nload('mydata.rda')\n# 2.14 Writing into files in ASCII format: write(), write.table() and write.csv()\n  # The write function accepts an R object and the name of a file or connection object, \n  # and writes an ASCII representation of the object to the appropriate destination. \na = c(one=1,two=2,three=3)\nwrite(a, file ='haha.txt')\nwrite.csv(t(a), file='haha.csv', row.names=FALSE) # Transpose first and exclude row.names\n\n\n# Chapter 5: Factors ------------------------------------------------------\n# 5.1 Using factors:\n  # Factors represent a very efficient way to store character values, \n  # because each unique character value is stored only once, \n  # and the data itself is stored as a vector of integers.\n# To create a factor, use factor()\n# To see the levels of the factor, use levels()\ndata = c(1,2,2,3,1,2,3,3,1,2,3,3,1)\nfdata = factor(data)\n# To assign roman numerals\nrdata = factor(data, labels = c('I', 'II', 'III'))\n# To convert default factor fdata to roman numerals, use levels()\nlevels(fdata) = c('I', 'II', 'III')\n# To convert ordinary vector to factor, use factor():\nmons = c('Mar','Apr','Jan','Feb','Mar','May','Jan','Mar')\nmons = factor(mons)\ntable(mons)\n# To create an ordered factor, use field ordered=TRUE. Example on page 69\n# 5.2 Numeric Factors:\n  # To convert the factor back to its original numeric values will enable arimethic\nfert = c(10,20,20,50,10,20,10,50)\nfert = factor(fert, levels=c(10,20,50), ordered=TRUE)\nlevels(fert)[fert] # Call the levels, then the [] part makes it into the long list\nmean(as.numeric(levels(fert)[fert])) # Either way works\nmean(as.numeric(as.character(fert)))\n\n# 5.3 Manipulating factors\nlets = sample(letters,size=100,replace=TRUE) # The letters vector is part of R base\nlets = factor(lets)\ntable(lets[1:15])\n# To drop levels without any count, use drop=TRUE\ntable(lets[1:15, drop=TRUE])\n  # To combine factors, they should first be converted back to their original values (through the levels function), \n  # then catenated and converted to a new factor, because c() will interpret the factors as integers\nfact1 = factor(sample(letters,size=10,replace=TRUE))\nfact2 = factor(sample(letters,size=10,replace=TRUE))\nfact12 = factor(c(levels(fact1)[fact1], levels(fact2)[fact2])) # Combining\n\n# 5.4 Creating factors from continuous var\n# 5.5 Factors based on Dates and Times\n# 5.6 Interactions\n\n\n# Chapter 6: Subscripting -------------------------------------------------\n# 6.1-6.2: Numeric subscripts: use to access the elements of a vector, array or list\n  # Negative subscripts in R extract all of the elements of an object except the ones \n  # specified in the negative subscript; thus, when using numeric subscripts,   \n  # subscripts must be either all positive (or zero) or all negative (or zero).\n\n# 6.3 Character Subscripts\n# 6.4 Logical Subscripts\nnums = c(12,9,8,14,7,16,3,2,9)\nnums > 10\n# To get all the elements > 10:\nnums[nums > 10]\n# To get all the subscripts of the elements for which > 10\nwhich(nums>10)\nseq(along=nums)[nums > 10]\n# To modify using subscript\nnums[nums > 10] = 0\n\n# 6.5 Subscripting Matrices and Arrays\nA = matrix(1:12,4,3)\n# To transpose a matrix use t()\nB = t(A)\n# To treat a matrix like a vector\nB[10] - B[1,4]\n# To get a sub-matrix\nB[2:3,1:2]\n# To use do.call: do exercise page 81\n\n# 6.6 Specialized functions for matrices\nmethod1 = c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)\nmethod2 = c(1,2,2,3,2,2,1,3,3,3,2,4,1,4,4,3)\n# To make a contigency table:\ntt = table(method1, method2)\n# To extract all the off-diagonal elements, need several steps\noffd = row(tt) != col(tt)\ntt[offd]\nsum(tt[offd])    # E.g: sum of the off-diagonal elements\n# To extract the upper and lower triangular elements of the matrix\nA[lower.tri(A)] <- NA\nA[upper.tri(A)] <- 0\nC = matrix(1:16,nrow=4,ncol=4)\nC[lower.tri(C,diag=TRUE)] <- NA\n\n# 6.7 Lists: most general way to store a collection of objects in R\nsimple = list(a=c('fred','sam','harry'),b=c(24,17,19,22))\nsimple$a[-2]\n# Note: simple[2] is not a vector, it's a list containing the vector\nsimple[2]\nmode(simple[2])\n# To do calculation, there are 2 ways to fix this:\n  # 1st: $ opperator\nmode(simple$b)\nmean(simple$b)\n  # 2nd: [[]] operator\nmean(simple[[2]])\nmean(simple[['b']])\n  # Note: single brackets will always return a list containing the selected elements,\n    # While [[]] returns the actual contents of selected list elements: E.g.\nsimple[1]\nsimple[[1]]\n\n# 6.8 Subscripting data frames\n# Data frames are a cross between a list and a matrix - so both technique applied\n  # However, when a single subscript is used with a data frame, it behaves like a list rather than a vector\ndd = data.frame(a=c(5,9,12,15,17,11),b=c(8,NA,12,10,NA,15))\ndd[dd$b > 10,]\n# To extract a subset in a dataframe - 1st way\ndd[!is.na(dd$b) & dd$b > 10,]\n\n# To extract a subset in a dataframe - 2nd way\nsubset(dd, b>10)\n# To extract only certain values of certain columns: use select=\nsome = subset(LifeCycleSavings,sr>10,select=c(pop15,pop75))\n# To extract from a range of column, use the : operator:\nlife1 = subset(LifeCycleSavings,select=pop15:dpi)\nlife1 = subset(LifeCycleSavings,select=1:3)\n\n# To extract from a range of columns, use:\nlife2 = subset(LifeCycleSavings, select=c(-pop15,-pop75))\nlife2 = subset(LifeCycleSavings, select=c(2,3))\n  ## Note: subset() always returns a new data frame, so it's not suited for modifying existing old frames\n\n\n# Chapter 7: Character Manipulation ---------------------------------------\n# 7.1 Basics of Character data\n# To find the lengths of each string elements\nstate.name\nnchar(state.name)\n# 7.2 Displaying and concatenating character strings\n# To combine character values and print them to the screen or a file directly\nx = 7\ny = 10\ncat('x should be >= y, but x=',x,'and y=',y,'\\n')\n\n# To automatically insert \\n into the output string, use field=\ncat('Long strings can','be displayed over',\n    'several lines using','the fill= argument', fill=40)\n\n# To print into a specific file, use file=, then use append=TRUE to append existing file\n# To join together several strings in specific ways, use paste()\npaste('one',2,'three',4,'five')\npaste('one',2,'three',4,'five', sep='-|-')\npaste(c('one','two','there','four'), collapse = ' ') # sep= will not work with vector here\npaste(c('one','two','there','four'), collapse = ' hahuhe ')\n\n# To generate variable names with a common prefix: (recycling shorter elements)\npaste('X',1:5,sep='') # This gives a vector of strings\npaste(c('X','Y'),1:5, sep='')\n  # Can use both sep= and collapse=\npaste(c('X','Y'),1:5,sep='_',collapse='|')\n\n# 7.3 Working with Parts of Character Values\n# To extract or to change the values of parts of character strings, use substring()\nsubstring(state.name,2,6)\n\nmystring = 'dog cat duck'\nsubstring(mystring,c(1,5,9),c(3,7,12))\nsubstring(mystring,5,7) = 'feline'\nsubstring(mystring,5,7) = 'a'\n\n# 7.4 Regular Expressions in R:\n  # Regular expressions are a method of expressing patterns in character values \n  # which can then be used to extract parts of strings or to modify those strings.\n\n  # Regular expressions are supported in the R functions: strsplit, grep, sub, gsub, regexpr, gregexpr\n  # E.g:\nexpr = '.*\\\\.txt'\nnchar(expr)\ncat(expr, '\\n')\n\n# To avoid the use of double backlashes, use readline()\nexpr = readline()\nnchar(expr)\n\n# 7.5 Basics of regular expressions: [page 92]\n# Regular expressions are composed of three components: \n  #   literal characters, which are matched by a single character; \n  #   character classes, which can be matched by any of a number of characters, and\n  #   modifiers, which operate on literal characters or character classes.\n    #Table 7.1 summarize all the modifiers\n\n# 7.6 Breaking apart character values\n  # To divide a character string into smaller pieces: use strsplit()\nsentence = 'R is a free software envi for statistical computing'\nparts = strsplit(sentence,split=' ') # The result is a list\nparts[[1]]\nparts[[1]][2]\nlength(parts)\nlength(parts[[1]])\n\n# To use strsplit() with a vector of strings, use sapply()\nmore = c('R is a free software environment for statistical computing',\n         'It compiles and runs on a wide variety of UNIX platforms')\nresult = strsplit(more, ' ')\nsapply(result, length)\n\n# To turn the outputs from list of lists, use \nresult.vec = unlist(result)\nlength(result.vec)\n\n# To deal with extra spaces in strings, twist the split='' a little bit\nstr = 'one  two   three four'\nstrsplit(str,split=' +')   # The plus sign represents one or more blanks\n\n# To split words into characters:\nwords =c('one two','three four')\nstrsplit(words,'')\n\n# 7.7 Using regular expression in R\n# To extract a set of variables from a data frame based on their names\ngrep('^pop',names(LifeCycleSavings))   # The '^pop' part serves as the pattern to search\ngrep('^pop',names(LifeCycleSavings), value=TRUE)  # Extract the real names\nLifeCycleSavings[,grep('^pop',names(LifeCycleSavings))]  # Combine with subscript - extract columns\n\n# To find regular expressions without regard to the case of the inputs, use ignore.case= TRUE\ninp = c('run dog run','work doggedly','CAT AND DOG')\ngrep('\\\\<dog\\\\>',inp,ignore.case=TRUE,value=TRUE)  \n    # Surrounding a string with '\\\\<    \\\\>' restrict matches to the case where the string is surrounded\n    # by either white space, punctuation or a line ending or beginning\n\n\n\n\n",
    "created" : 1388758233708.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2123077341",
    "id" : "FC8F1294",
    "lastKnownWriteTime" : 1389186246,
    "path" : "~/Program/R/Data.Manipulation.R/Data.Manipulation.R",
    "project_path" : "Data.Manipulation.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}