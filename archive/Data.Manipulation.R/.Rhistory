# To name the elements of vectors, there are 2 ways:
x = c(one=1, two=2, three=3)
y = c(1,2,3)
names(y) = c('one','two', 'three')
# To make a matrix:
rmat = matrix(rnorm(15), 5, 3, dimnames= list(NULL, c('A', 'B', 'C')))
# To change the names of columns in matrix
dimnames(rmat) = list(NULL,c('A','B','C'))
# To call a column in a matrix
rmat[,'A']
# To make a list
mylist = list(c(1,4,6),"dog",3,"cat",TRUE,c(9,10,11))
# To call/change a element in a list
mylist[1]
mylist[4] = 'catttt'
# To name list's elements: 2 ways
mylist = list(first=c(1,3,5), second=c('one','three','five'),third='end')
# or
mylist = list(c(1,3,5),c(’one’,’three’,’five’),’end’)
names(mylist) = c(’first’,’second’,’third’)
# A data frame is a list that each element (the variables) must be of the same length as every other element
# Some function to test mode:   is.list, is.factor, is.numeric, is.data.frame, and is.character
# To view structure of a nested list, use str()
nestlist = list(a=list(matrix(rnorm(10),5,2),val=3),
b=list(sample(letters,10),values=runif(5)),
c=list(list(1:10,1:20),list(1:5,1:10)))
str(nestlist)
# To convert types of objects, use as.
nums = c(12,10,8,12,10,12,8,10,12,8)
tt = table(nums)
names(tt)
sum(as.numeric(names(tt)) * tt)
# To test missing values, use is.na
# Chapter 2: Reading and Writing Data -------------------------------------\
# 2.1 Reading Vectors and Matrices
# To use standard input:
names = scan(what="") # A prompt will show up
# To read into a matrix through a prompt, use a nested scan()
mymat = matrix(scan(),ncol=3,byrow=TRUE) # Notice the byrow = TRUE
# To skip fields while reading in data with scan(), use NULL to pass on 'what'
# Suppose we only need to read the contents of the first, third, and tenth fields:
toskip = c(f1=0,NULL,f3=0,rep(list(NULL),6),f10=0)
values = scan(filename, what=toskip) # Code will not run btw
result = cbind(values$f1,values$f3,values$f10)
# 2.2 Data frame: read.table(), which always returns a data frame and automatically convert data
# To avoid conversion, use as.is = TRUE
# 2.3 Comma and tab-delimited input files: use read.csv(), read.csv2(), read.delim()
# 2.4 Fixed-width input files: use read.fwf()
# 2.5 Extracting from R objects: use a set of appropriate functions with each class
# use apropos() to find all such function, for example:
apropos('.*\\.lm$')
apropos('.*\\.anova$')
# use names() to get all elements in each objects, then extract using & or []:
#   slm$df.residual is equivalent to slm['df.residual']
# 2.6 & 2.7 Connections: read from files or server - page 23. Will come back
# 2.8 Generating data
# Sequences
1:10
seq(1,10)
1:10 - seq(1,10)
seq(10,100,5)
seq(10, by=5, length=10)
# Generating levels: use gl():
thelevels = data.frame(group=gl(3,10,length=30),
subgroup=gl(5,2,length=30),
obs=gl(2,1,length=30))
# expand.grid() - very cool!
oe = expand.grid(odd=seq(1,5,by=2), even=seq(2,5,by=2))
# Random numbers: eg: rbinom() or rlogis() etc... Full table page 29
# 2.9 Permutations: use sample() and factorial(n)
# 2.10 Working with sequences:
# 2.11 Spreadsheets: RODBC (win only) and gdata packages
# 2.12 Saving into .RData or .rda files: use save() and load()
save(list=c('x','y','z'),file='mydata.rda')
load('mydata.rda')
# 2.14 Writing into files in ASCII format: write(), write.table() and write.csv()
# The write function accepts an R object and the name of a file or connection object,
# and writes an ASCII representation of the object to the appropriate destination.
a = c(one=1,two=2,three=3)
write(a, file ='haha.txt')
write.csv(t(a), file='haha.csv', row.names=FALSE) # Transpose first and exclude row.names
# Chapter 5: Factors ------------------------------------------------------
# 5.1 Using factors:
Factors represent a very efficient way to store character values, because each unique character value is stored only once, and the data itself is stored as a vector of integers.
# To create a factor, use factor()
# To see the levels of the factor, use levels()
# Chapter 1: Data, Modes & classes ----------------------------------------
mode()
class()
typeof()
# Matrices or other arrays require all the data contained to be in the same mode
# Lists and dataframes allow for multiple modes within an object
# The most primitive mode of data is char
x = c(1,2,5,10, TRUE)
mode(x)
y = c(1,2,"cat", 5)
mode(y)
z = c(x, y) #You can combine vectors to make a new vactor
# To name the elements of vectors, there are 2 ways:
x = c(one=1, two=2, three=3)
y = c(1,2,3)
names(y) = c('one','two', 'three')
# To make a matrix:
rmat = matrix(rnorm(15), 5, 3, dimnames= list(NULL, c('A', 'B', 'C')))
# To change the names of columns in matrix
dimnames(rmat) = list(NULL,c('A','B','C'))
# To call a column in a matrix
rmat[,'A']
# To make a list
mylist = list(c(1,4,6),"dog",3,"cat",TRUE,c(9,10,11))
# To call/change a element in a list
mylist[1]
mylist[4] = 'catttt'
# To name list's elements: 2 ways
mylist = list(first=c(1,3,5), second=c('one','three','five'),third='end')
# or
mylist = list(c(1,3,5),c(’one’,’three’,’five’),’end’)
names(mylist) = c(’first’,’second’,’third’)
# A data frame is a list that each element (the variables) must be of the same length as every other element
# Some function to test mode:   is.list, is.factor, is.numeric, is.data.frame, and is.character
# To view structure of a nested list, use str()
nestlist = list(a=list(matrix(rnorm(10),5,2),val=3),
b=list(sample(letters,10),values=runif(5)),
c=list(list(1:10,1:20),list(1:5,1:10)))
str(nestlist)
# To convert types of objects, use as.
nums = c(12,10,8,12,10,12,8,10,12,8)
tt = table(nums)
names(tt)
sum(as.numeric(names(tt)) * tt)
# To test missing values, use is.na
# Chapter 2: Reading and Writing Data -------------------------------------\
# 2.1 Reading Vectors and Matrices
# To use standard input:
names = scan(what="") # A prompt will show up
# To read into a matrix through a prompt, use a nested scan()
mymat = matrix(scan(),ncol=3,byrow=TRUE) # Notice the byrow = TRUE
# To skip fields while reading in data with scan(), use NULL to pass on 'what'
# Suppose we only need to read the contents of the first, third, and tenth fields:
toskip = c(f1=0,NULL,f3=0,rep(list(NULL),6),f10=0)
values = scan(filename, what=toskip) # Code will not run btw
result = cbind(values$f1,values$f3,values$f10)
# 2.2 Data frame: read.table(), which always returns a data frame and automatically convert data
# To avoid conversion, use as.is = TRUE
# 2.3 Comma and tab-delimited input files: use read.csv(), read.csv2(), read.delim()
# 2.4 Fixed-width input files: use read.fwf()
# 2.5 Extracting from R objects: use a set of appropriate functions with each class
# use apropos() to find all such function, for example:
apropos('.*\\.lm$')
apropos('.*\\.anova$')
# use names() to get all elements in each objects, then extract using & or []:
#   slm$df.residual is equivalent to slm['df.residual']
# 2.6 & 2.7 Connections: read from files or server - page 23. Will come back
# 2.8 Generating data
# Sequences
1:10
seq(1,10)
1:10 - seq(1,10)
seq(10,100,5)
seq(10, by=5, length=10)
# Generating levels: use gl():
thelevels = data.frame(group=gl(3,10,length=30),
subgroup=gl(5,2,length=30),
obs=gl(2,1,length=30))
# expand.grid() - very cool!
oe = expand.grid(odd=seq(1,5,by=2), even=seq(2,5,by=2))
# Random numbers: eg: rbinom() or rlogis() etc... Full table page 29
# 2.9 Permutations: use sample() and factorial(n)
# 2.10 Working with sequences:
# 2.11 Spreadsheets: RODBC (win only) and gdata packages
# 2.12 Saving into .RData or .rda files: use save() and load()
save(list=c('x','y','z'),file='mydata.rda')
load('mydata.rda')
# 2.14 Writing into files in ASCII format: write(), write.table() and write.csv()
# The write function accepts an R object and the name of a file or connection object,
# and writes an ASCII representation of the object to the appropriate destination.
a = c(one=1,two=2,three=3)
write(a, file ='haha.txt')
write.csv(t(a), file='haha.csv', row.names=FALSE) # Transpose first and exclude row.names
# Chapter 5: Factors ------------------------------------------------------
# 5.1 Using factors:
Factors represent a very efficient way to store character values, because each unique character value is stored only once, and the data itself is stored as a vector of integers.
# To create a factor, use factor()
# To see the levels of the factor, use levels()
# Chapter 1: Data, Modes & classes ----------------------------------------
mode()
class()
typeof()
# Matrices or other arrays require all the data contained to be in the same mode
# Lists and dataframes allow for multiple modes within an object
# The most primitive mode of data is char
x = c(1,2,5,10, TRUE)
mode(x)
y = c(1,2,"cat", 5)
mode(y)
z = c(x, y) #You can combine vectors to make a new vactor
# To name the elements of vectors, there are 2 ways:
x = c(one=1, two=2, three=3)
y = c(1,2,3)
names(y) = c('one','two', 'three')
# To make a matrix:
rmat = matrix(rnorm(15), 5, 3, dimnames= list(NULL, c('A', 'B', 'C')))
# To change the names of columns in matrix
dimnames(rmat) = list(NULL,c('A','B','C'))
# To call a column in a matrix
rmat[,'A']
# To make a list
mylist = list(c(1,4,6),"dog",3,"cat",TRUE,c(9,10,11))
# To call/change a element in a list
mylist[1]
mylist[4] = 'catttt'
# To name list's elements: 2 ways
mylist = list(first=c(1,3,5), second=c('one','three','five'),third='end')
# or
mylist = list(c(1,3,5),c(’one’,’three’,’five’),’end’)
names(mylist) = c(’first’,’second’,’third’)
# A data frame is a list that each element (the variables) must be of the same length as every other element
# Some function to test mode:   is.list, is.factor, is.numeric, is.data.frame, and is.character
# To view structure of a nested list, use str()
nestlist = list(a=list(matrix(rnorm(10),5,2),val=3),
b=list(sample(letters,10),values=runif(5)),
c=list(list(1:10,1:20),list(1:5,1:10)))
str(nestlist)
# To convert types of objects, use as.
nums = c(12,10,8,12,10,12,8,10,12,8)
tt = table(nums)
names(tt)
sum(as.numeric(names(tt)) * tt)
# To test missing values, use is.na
# Chapter 2: Reading and Writing Data -------------------------------------\
# 2.1 Reading Vectors and Matrices
# To use standard input:
names = scan(what="") # A prompt will show up
# To read into a matrix through a prompt, use a nested scan()
mymat = matrix(scan(),ncol=3,byrow=TRUE) # Notice the byrow = TRUE
# To skip fields while reading in data with scan(), use NULL to pass on 'what'
# Suppose we only need to read the contents of the first, third, and tenth fields:
toskip = c(f1=0,NULL,f3=0,rep(list(NULL),6),f10=0)
values = scan(filename, what=toskip) # Code will not run btw
result = cbind(values$f1,values$f3,values$f10)
# 2.2 Data frame: read.table(), which always returns a data frame and automatically convert data
# To avoid conversion, use as.is = TRUE
# 2.3 Comma and tab-delimited input files: use read.csv(), read.csv2(), read.delim()
# 2.4 Fixed-width input files: use read.fwf()
# 2.5 Extracting from R objects: use a set of appropriate functions with each class
# use apropos() to find all such function, for example:
apropos('.*\\.lm$')
apropos('.*\\.anova$')
# use names() to get all elements in each objects, then extract using & or []:
#   slm$df.residual is equivalent to slm['df.residual']
# 2.6 & 2.7 Connections: read from files or server - page 23. Will come back
# 2.8 Generating data
# Sequences
1:10
seq(1,10)
1:10 - seq(1,10)
seq(10,100,5)
seq(10, by=5, length=10)
# Generating levels: use gl():
thelevels = data.frame(group=gl(3,10,length=30),
subgroup=gl(5,2,length=30),
obs=gl(2,1,length=30))
# expand.grid() - very cool!
oe = expand.grid(odd=seq(1,5,by=2), even=seq(2,5,by=2))
# Random numbers: eg: rbinom() or rlogis() etc... Full table page 29
# 2.9 Permutations: use sample() and factorial(n)
# 2.10 Working with sequences:
# 2.11 Spreadsheets: RODBC (win only) and gdata packages
# 2.12 Saving into .RData or .rda files: use save() and load()
save(list=c('x','y','z'),file='mydata.rda')
load('mydata.rda')
# 2.14 Writing into files in ASCII format: write(), write.table() and write.csv()
# The write function accepts an R object and the name of a file or connection object,
# and writes an ASCII representation of the object to the appropriate destination.
a = c(one=1,two=2,three=3)
write(a, file ='haha.txt')
write.csv(t(a), file='haha.csv', row.names=FALSE) # Transpose first and exclude row.names
# Chapter 5: Factors ------------------------------------------------------
# 5.1 Using factors:
Factors represent a very efficient way to store character values, because each unique character value is stored only once, and the data itself is stored as a vector of integers.
# To create a factor, use factor()
mons = factor(mons)
mons = c('Mar','Apr','Jan','Feb','Mar','May','Jan','Mar')
mons = factor(mons)
mons
mons = factor(mons)
tables(mons)
table(mons)
fert = c(10,20,20,50,10,20,10,50)
fert = factor(fert, levels=c(10,20,50), ordered=TRUE)
fert
mean(as.numeric(levels(fert)[fert]))
mean(as.numeric(as.character(fert)))
ha = as.character(fert)
ha
ha = as.numeric(fert)
ha
ha = as.numeric(level(fert))
ha = as.numeric(levels(fert))
ha
ha = as.numeric(levels(fert)[fert])
ha
levels(fert)[fert]
lets = sample(letters,size=100,replace=TRUE)
lets = factor(lets)
table(lets[1:5])
lets
table(lets[1:15])
table(lets[1:15])
lets = factor(lets)
table(lets[1:15])
table(lets[1:15], drop=TRUE)
table(lets[1:15, drop=TRUE])
table(lets[1:15, drop=TRUE])
clear
clear()
fact12 = factor(c(levels(fact1)[fact1], levels(fact2)[fact2]))
fact1 = factor(sample(letters,size=10,replace=TRUE))
fact2 = factor(sample(letters,size=10,replace=TRUE))
fact12 = factor(c(levels(fact1)[fact1], levels(fact2)[fact2]))
fact12
nums = c(12,9,8,14,7,16,3,2,9)
nums > 10
nums = c(12,9,8,14,7,16,3,2,9)
nums > 10
# To get all the elements > 10:
nums[nums > 10]
seq(along=nums)[nums > 10]
nums[nums > 10] = 0
nums
matrix(1:12,4,3)
A = matrix(1:12,4,3)
A[2,]
A[2,2]
A[,2]
A[,2] * 2:5
t(A[,2]) * t(2:5)
B = t(A)
B
B[10]
B[10] - B[2,3]
B[10] - B[1,4]
B[2:3,1:2]
method1 = c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
method2 = c(1,2,2,3,2,2,1,3,3,3,2,4,1,4,4,3)
tt = table(method1, method2)
tt
offd = row(tt) - col(tt)
pffd
offd
offd = row(tt) != col(tt)
offd
tt[offd]
lower.tri(A)
A
A[lower.tri(A)]
t(lower.tri(A))*A
t(lower.tri(A))
t(lower.tri(A))**A
A
A*t(A)
A %*% t(lower.tri(A))
A[upper.tri(A)] <- 0
A
A[lower.tri(A)] <- NA
A
C = matrix(1:16,nrow=4,ncol=4,byrow=TRUE)
C[lower.tri(A,diag=TRUE)] <- 0
C
C = matrix(1:16,nrow=4,ncol=4,byrow=TRUE)
C
C[lower.tri(A,diag=TRUE)] <- NA
C
C[lower.tri(A,diag=FALSE)] <- NA
C
C = matrix(1:16,nrow=4,ncol=4,byrow=TRUE)
C[lower.tri(A,diag=FALSE)] <- NA
C = matrix(1:16,nrow=4,ncol=4,byrow=TRUE)
C[lower.tri(A,diag=FALSE)] <- NA
C
C = matrix(1:16,nrow=4,ncol=4)
C
lower.tri(A,diag=FALSE)
C[lower.tri(C,diag=TRUE)] <- NA
C
simple = list(a=c(’fred’,’sam’,’harry’),b=c(24,17,19,22))
simple = list(a=c('fred','sam','harry'),b=c(24,17,19,22))
simple
simple$a
simple$a[1]
simple$a[-2]
simple[2]
mode(simple[2])
mode(simple$b)
mean(simple$b)
mean(simple[[2]])
simple[1]
simple[[1]]
dd = data.frame(a=c(5,9,12,15,17,11),b=c(8,NA,12,10,NA,15))
d
dd
dd[dd&b > 10,]
dd = data.frame(a=c(5,9,12,15,17,11),b=c(8,NA,12,10,NA,15))
dd[dd&b > 10,]
dd = data.frame(a=c(5,9,12,15,17,11),b=c(8,NA,12,10,NA,15))
dd$b
dd[dd$b > 10,]
dd
dd[!is.na(dd$b) & dd$b > 10,]
subset(dd, b>10)
LifeCycleSavings
some = subset(LifeCycleSavings,sr>10,select=c(pop15,pop75))
some
life1 = subset(LifeCycleSavings,select=pop15:dpi)
life1 = subset(LifeCycleSavings,select=1:3)
View(life1)
life2 = subset(LifeCycleSavings, select=c(2,3))
life2
nchar(state.name)
state.name
x = 7
y = 10
cat('x should be >= y, but x=', x, 'and y=', y)
cat('x should be >= y, but x=',x,'and y=',y)
fill=40)
fill=40)
cat('Long strings can’,’be displayed over',
'several lines using’,’the fill= argument',
fill=40)
'several lines using’,’the fill= argument',
cat('Long strings can','be displayed over',
'several lines using’,’the fill= argument',
fill=40)
cat('Long strings can','be displayed over',
'several lines using','the fill= argument', fill=40)
paste(c('one','two','there','four'), collapse = ' hahuhe ')
paste('one',2,'three',4,'five', sep='-|-')
paste('X',1:5,sep=' ')
paste('X',1:5,sep='')
paste('X',1:5,sep='')[1]
paste(c('X','Y'),1:5, sep='')
paste(c(’X’,’Y’),1:5,sep=’_’,collapse=’|’)
paste(c('X','Y'),1:5,sep='_',collapse='|')
mystring = ’dog cat duck’
substring(mystring,c(1,5,9),c(3,7,12))
mystring = 'dog cat duck'
substring(mystring,c(1,5,9),c(3,7,12))
\\.txt'
nchar(expr
expr = '.*\\.txt'
nchar(expr)
expr = '.*\\.txt'
nchar(expr)
cat(expr, '\n')
expr
expr + '\n'
append(expr,  '\n')
append(expr,  \n)
expr1 = cat(expr, '\n')
expr1
expr = '.*\\.txt'
expr
cat(expr, '\n')
expr
expr = readline()
expr
sentence = 'R is a free software envi for statistical computing'
sentence
parts = strsplit(sentence,' ')
parts
parts = strsplit(sentence,split=' ')
parts
parts[1]
parts[[1]]
parts[[1]][2]
parts[[1]][2]
parts[[1]]
length(parts)
length(parts[[1]])
parts[[2]]
result = strsplit(more, ' ')
more = c('R is a free software environment for statistical computing',
'It compiles and runs on a wide variety of UNIX platforms')
result = strsplit(more, ' ')
sapply(result, length)
result
unlist(result)
more = c('R is a free software environment for statistical computing',
'It compiles and runs on a wide variety of UNIX platforms')
result = strsplit(more, ' ')
sapply(result, length)
unlist(result)
length(result)
result
length(result.vec)
result.vec = unlist(result)
length(result.vec)
strsplit(str,split=' +')   # The plus sign represents one or more blanks
str = 'one  two   three four'
strsplit(str,split=' +')   # The plus sign represents one or more blanks
words =c('one two','three four')
strsplit(words,'')
grep('^pop',names(LifeCycleSavings))
grep('^pop',names(LifeCycleSavings), value=TRUE)
grep('^pop',names(LifeCycleSavings))   # The '^pop' part serves as the pattern to search
grep('^pop',names(LifeCycleSavings), value=TRUE)
head(LifeCycleSavings[,grep(’^pop’,names(LifeCycleSavings))])
head(LifeCycleSavings[,grep('^pop',names(LifeCycleSavings))])
LifeCycleSavings[,grep('^pop',names(LifeCycleSavings))]  # Combine with subscript - extract columns
inp = c('run dog run','work doggedly','CAT AND DOG')
grep('\\<dog\\>',inp,ignore.case=TRUE)
grep('\\<dog\\>',inp,ignore.case=TRUE,value=TRUE)
